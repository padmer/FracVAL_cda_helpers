#Define functions for use in other script files

#load necessary libraries
library(cda)
library(dielectric)
library(ggplot2)
library(gridExtra)
library(reshape2)
library(plyr)
library(rgl)
library(matrixStats)


#Load individual .dat files ouput by FracVAL into R
read_cda_file<-function(file){
  #open file and read all lines
  cona=file(file)
  txt<-readLines(cona)
  close(cona)
  
  #Initialise matrix which will hold all values (x,y,z and radius)
  values_all<-matrix(0,4,length(txt))
  
  #Iterate over lines in the file
  for (i in 1:length(txt)) {
    #grab line for paranoia
    currline=txt[i]
    
    #split the line according to spaces
    currline_split<-strsplit(currline," ")
    
    #iterate over the different sections of the split line and if the section is not empty store it as a double
    vals=c(0,0,0,0)
    counter=1
    for (ii in 1:length(currline_split[[1]])){
      if (currline_split[[1]][ii]!=""){
        vals[counter]<-as.double(currline_split[[1]][ii])
        counter=counter+1
      }
    }
    
    #populate the matrix with values
    values_all[,i]<-vals
  }
  return(values_all)
}


#function to load files generated by FracVAL into a cda friendly structure 
loadaggregate <- function(filename,folder) {
  #read in the FracVAL .dat file
  data<-read_cda_file(paste(folder,filename,sep=""))
  
  #seperate the position data from the radii
  posfrac<-data[1:3,]
  
  #Generate a cda friendly set of clusters to populate with the new data
  clust_frac<-cluster_chain((length(data[1,])+1), pitch=20, a=20, b=20, c=20)
  
  #add the positions of each primary particle to the structure and also at the end the center of the aggregate
  clust_frac$positions<-cbind(posfrac,rowMeans(posfrac))-rowMeans(posfrac)
  
  #add the sizes of each primary particle to the structure and also at the end the size of the middle particle
  clust_frac$sizes<-cbind(matrix(rep(data[4,],3),3,byrow=TRUE),rep(20,3))
  return(clust_frac)
}


#Function to calculate the orientation averaged dispersion spectrum of a cluster
Calc_clust_or_avg<-function(clust,material="Ag",Nscaval=600,wavelength=c(300,900),numq=25){
  #Define material parameters
  if (material=="Ag"){
    eps <- epsAg(seq(wavelength[1], wavelength[2]))
  } else if (material=="Au") {
    eps<-epsAu(seq(wavelength[1], wavelength[2]))
  } else {
    eps<-epsAg(seq(wavelength[1], wavelength[2]))
    warning("Material not recognised, using silver")
  }
  
  #remove the particle indicating the center of the aggregate from the structure
  lengthclust<-length(clust$positions[1,])
  clusttrimmed<-clust
  clusttrimmed$positions<-clust$positions[,1:(lengthclust-1)]
  clusttrimmed$sizes<-clust$sizes[,1:(lengthclust-1)]
  clusttrimmed$angles<-clust$angles[,1:(lengthclust-1)]
  
  #calculate the spectrum
  valsout<-spectrum_oa(clusttrimmed, eps, quadrature = "gl", Nq = numq,Nsca=Nscaval)
  return(valsout)
}


#Function to return the mean extinction and absorbance values for a set of aggregates 
#(for instance from a folder generated by FracVAL) 
get_aggregate_mean_oa<-function(clusters,num_agg){
  #Define the wavelength range of interest
  wavelengths=c(300,900)
  num_wl=length(seq(wavelengths[1],wavelengths[2]))
  
  #Initialise matrices to store the outputs
  valsoutallabs<-matrix(0,num_agg,num_wl)
  wavoutallabs<-matrix(0,num_agg,num_wl)
  valsoutallext<-matrix(0,num_agg,num_wl)
  wavoutallext<-matrix(0,num_agg,num_wl)
  
  #Iterate over each aggregate and calculate the dispersion spectrum and extract the absorption and extinction values
  for (i in 1:num_agg){
    tmpres<-Calc_clust_or_avg(clusters[[i]])
    tmpresabs<-subset(tmpres, type=="cross-section" & variable =="absorption")
    valsoutallabs[i,]<-tmpresabs$value
    wavoutallabs[i,]<-tmpresabs$wavelength
    tmpresext<-subset(tmpres, type=="cross-section" & variable =="extinction")
    valsoutallext[i,]<-tmpresext$value
    wavoutallext[i,]<-tmpresext$wavelength
  }
  
  #Take averages of the values obtained for all aggregates
  valsabs<-colMeans(valsoutallabs)
  wavabs<-colMeans(wavoutallabs)
  valsext<-colMeans(valsoutallext)
  wavext<-colMeans(wavoutallext)
  
  #Store in dataframes for easy handling
  meanvalsext<-data.frame(wavext,valsext)
  meanvalsabs<-data.frame(wavabs,valsabs)
  return(list(meanvalsabs,meanvalsext))
}


#Load all aggregates from a folder and store in a set of clusters.
#Calculate the mean absorbance and extinction values of the aggregates
get_mean_from_fold_oa<-function(fold){
  
  #find all .dat files in the target folder
  files<-Sys.glob(paste(fold,"\\*.dat",sep=""))
  num_agg=length(files)

  #load the identified files in and store each cluster in "clusters"
  clusters<-list()
  for (i in 1:num_agg){
    clusters[[length(clusters)+1]]<-loadaggregate(files[i],folder="")
  }
  
  #calculate the mean absorbance and extinction spectra
  meanvals<-get_aggregate_mean_oa(clusters,num_agg)
  return(meanvals)
}


#an attempt to clarify the operation of separating the primary particles by
#applying a multiplication factor to their position vector
adjust_spacing <- function(clust,multi){
  clust$positions<-clust$positions*multi
  return(clust)
}


#Apply the interparticle spacing adjustment to all aggregates in a set
adjust_spacing_many<-function(clusters,multfact){
  for (i in 1:length(clusters)){
    clusters[[i]]<-adjust_spacing(clusters[[i]],multfact)
  }
  return(clusters)
}


#Calculate the interparticle distances for an aggregate
get_interpart_distance<-function(clust){
  
  #Seperate out the individual elements for clarity
  vals<-clust$positions
  vals_size<-clust$sizes
  
  #Initialise a list to store the values
  mean_interparticle_distances<-list()
  
  #iterate over each primary particle
  num_PP<-length(vals[1,])
  for (Curr_PP in 1:(num_PP-1)){
    #subtract the current particle position from all other particle positions
    valstemp<-vals[,1:(num_PP-1)]-vals[,Curr_PP]
    
    #Get the radii of the primary particles used
    vals_sizes_temp<-vals_size[1,1:(num_PP-1)]
    
    #remove the radius of the current primary particle from the list
    vals_sizes_temp<-vals_sizes_temp[-Curr_PP]
    
    #Store the radius of the current primary particle seperately
    Curr_PP_size<-vals_size[1,Curr_PP]
    
    #calculate the distance of all particles from (0,0,0) point (the current primary particles center)
    temp<-list()
    for (i in 1:length(valstemp[1,])){
      temp[[i]]<-list(sqrt(valstemp[,i][[1]]^2+valstemp[,i][[2]]^2+valstemp[,i][[3]]^2))[[1]]
    }
    
    #remove the value of the current primary particle
    temp[[Curr_PP]]<-NULL
    temp=unlist(temp, use.names=FALSE)
    
    #calculate the distance between the particles taking into account their radii
    Interpart_distance<-temp-(vals_sizes_temp+Curr_PP_size)
    Interpart_distance<-unlist(Interpart_distance,use.names = FALSE)
    
    #Found the smallest two values in the above list
    closest_two<-Rfast::nth(Interpart_distance, 2, num.of.nths = 2, descending = F)
    
    #take the mean of the closest two particles and store it
    mean_interparticle_distances[[Curr_PP]]<-mean(closest_two)
  }
  
  return(unlist(mean_interparticle_distances,use.names = FALSE))
}


#Calculate the mean interparticle distances between the primary particles of a set of aggregates
get_many_interpart_distance<-function(clusters){
  
  #Initialise the arrays
  num_clust=length(clusters)
  num_PP<-length(get_interpart_distance(clusters[[1]]))
  
  #intialise matrix to store the values
  many_interpart_distance<-matrix(0,num_clust,num_PP)
  
  #iterate over each cluster and store the values of the mean interparticle distances
  for (i in 1:num_clust){
    many_interpart_distance[i,]<-get_interpart_distance(clusters[[i]])
  }
  
  #Return the mean of the two closest particles for every primary particle in each aggregate
  return(colMeans(many_interpart_distance))
}


#calcuate the mean interparticle distance for a set of aggregates in fold and operated 
#on by a set of multipliers "spac"
get_mean_std_interpart<-function(fold,spac){
  
  #Load the files into clusters
  files<-Sys.glob(paste(wd_fold,"/",fold,"/*.dat",sep=""))
  num_agg=length(files)
  clusters<-list()
  for (i in 1:num_agg){
    clusters[[length(clusters)+1]]<-loadaggregate(files[i],folder="")
  }
  
  #Iterate over each desired multiplier and calculate the interparticle distance
  clustersa_dist<-list()
  for (i in 1:length(spac)){
    clustersa_dist[[length(clustersa_dist)+1]]<-get_many_interpart_distance(adjust_spacing_many(clusters,spac[i]))
  }
  clustersa_dist <- matrix(unlist(clustersa_dist), nrow = length(spac), byrow = TRUE)
  
  #calculate the mean and standard deviation of all interparticle primary distances of the averaged aggregate values
  dist_mean<-rowMeans(clustersa_dist)
  dist_std<-rowSds(clustersa_dist)
  
  return(list("x"=spac,"dist"=dist_mean,"dist_std"=dist_std))
}
